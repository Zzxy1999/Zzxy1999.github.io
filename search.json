[{"title":"6.s081 syscall","path":"/2025/01/15/6-s081-syscall/","content":"0. 前言6.s081是MIT开设的os课，前段时间把所有lab都写完了，最近有空便结合xv6记录一下收获～课程链接在这https://pdos.csail.mit.edu/6.828/2022/个人的lab实现在这https://github.com/Zzxy1999/6.s081 1. xv6如何启动的？1.1 boot loader到entry电源打开后，计算机将会执行一段叫boot loader的程序，这段程序存储在ROM里，把它加载进内存后，CPU便开始执行。boot load会从磁盘固定位置上加载内核的一小段程序entry.S。 _entry:\t# set up a stack for C.\t# stack0 is declared in start.c,\t# with a 4096-byte stack per CPU.\t# sp = stack0 + (hartid * 4096)\tla sp, stack0\tli a0, 1024*4\tcsrr a1, mhartid\taddi a1, a1, 1\tmul a0, a0, a1\tadd sp, sp, a0\t# jump to start() in start.c\tcall start entry做的工作包括了初始化一个C栈，随后在+4096的位置设置相应的栈指针，有了内核栈之后，entry将程序控制权转到了C代码start.c处。 1.2 startvoid main();/ entry.S jumps here in machine mode on stack0.voidstart()\t... // set M Exception Program Counter to main, for mret. // requires gcc -mcmodel=medany w_mepc((uint64)main); // switch to supervisor mode and jump to main(). asm volatile(mret); start内部做了一些初始化工作，随后要正式进入os的main函数了。注意到start并不是被函数调用的，而是直接修改pc跳转过来的。这里要把控制权从start转移到main，用的方法是设置函数结束后ret的地址到main的起始地址，随后执行ret指令，这样就将控制权转移到了main处。 1.3 mainvoidmain() if(cpuid() == 0) consoleinit(); printfinit(); printf( ); printf(xv6 kernel is booting ); printf( ); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode table fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; else while(started == 0) ; __sync_synchronize(); printf(hart %d starting , cpuid()); kvminithart(); // turn on paging trapinithart(); // install kernel trap vector plicinithart(); // ask PLIC for device interrupts scheduler(); 可以看到，main内执行了一大堆os的初始化操作，随后的scheduler会正式开启cpu的调度。各个模块的初始化后面的lab会又提其，这里重点看下userinit，即第一个用户进程，init进程。 1.4 userinitvoiduserinit(void) struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy initcodes instructions // and data into it. uvmfirst(p-pagetable, initcode, sizeof(initcode)); p-sz = PGSIZE; // prepare for the very first return from kernel to user. p-trapframe-epc = 0; // user program counter p-trapframe-sp = PGSIZE; // user stack pointer safestrcpy(p-name, initcode, sizeof(p-name)); p-cwd = namei(/); p-state = RUNNABLE; release(p-lock); 这里看到，正常的进程都是由父进程创建的，他们的栈、pc等都和父进程有关。而init进程是由内核直接创建，所以需要内核帮它设置这些必要的参数。可以看到它的栈被内核设置在了PGSIZE处，它的pc被设置在了0地址处（这里并非简单的设置，和后面的trap有关）。而0地址有一段汇编代码initcode.S，这里不再贴出，其具体作用是执行exec系统调用，执行init程序。 1.5 initintmain(void) int pid, wpid; if(open(console, O_RDWR) 0) mknod(console, CONSOLE, 0); open(console, O_RDWR); dup(0); // stdout dup(0); // stderr for(;;) printf(init: starting sh ); pid = fork(); if(pid 0) printf(init: fork failed ); exit(1); if(pid == 0) exec(sh, argv); printf(init: exec sh failed ); exit(1); for(;;) // this call to wait() returns if the shell exits, // or if a parentless process exits. wpid = wait((int *) 0); if(wpid == pid) // the shell exited; restart it. break; else if(wpid 0) printf(init: wait returned an error ); exit(1); else // it was a parentless process; do nothing. 到init这里起始就好懂不少，打开console，然后重定向。随后init自己创建一个进程，这个进程就是第二个用户进程，执行sh程序，也就是一个shell，随后就是无尽的循环了～到此xv6启动完毕，同时提供给了用户一个终端进行操作。 2. lab util先放链接https://pdos.csail.mit.edu/6.828/2022/labs/util.html第一个lab很简单，task1是在qemu内启动xv6,执行几个命令行就ok了;task2是编写几个用户程序，比如find xargs这种，xv6本身就提供了不少系统调用，所以就直接用系统调用函数写就ok了，这里不再赘述了。 3. 系统调用是怎么执行的？为什么要有系统调用？原因是用户需要执行一个操作，为了安全考虑，这些操作必须要在内核完成，所以就要借助系统调用，让内核帮自己完成这些操作。下面看下xv6中，系统调用的过程。 进入内核在用户程序中调用系统调用函数，cpu会设定对应系统调用的编号，随后执行ecall指令，ecall将会把程序控制流带到trampoline.S这里。trampoline.S内是一系列汇编代码，做的工作包括：保存寄存器，一些进入内核的准备工作，移动栈指针到内核栈，随后跳转到内核的usertrap函数。 进入内核的寄存器设置riscv中，有很多寄存器都有着特定的标识作用，下面列出了系统调用相关的寄存器，他们在进入内核时都以及被设置好了。 stvec: 里面记录着处理trap的地址 sepc: 进入内核后，返回到用户空间的地址 scause: trap原因 sstatus: trap由内核引发还是用户引发 下面用gdb简单的验证一下stvec寄存器的地址在哪。 打印stvec寄存器的值，为0x80005120 看看0x80005120到底是哪，发现是kernelvec的地址，在kernelvec.S中，是处理内核trap的位置 stvec存储的是kernelvec的地址，原因是gdb停在了内核态下面执行一个用户程序，进入用户空间看看stvec寄存器的值。 简单执行一个ls程序，并在执行系统调用open前，打印stvec的值0x3ffffff000 断点到0x3ffffff000处，发现这里是trampoline.S的地方，符合预期。 4. lab syscall先放链接https://pdos.csail.mit.edu/6.828/2022/labs/syscall.html第二个lab算是正式接触os了，"},{"title":"CSAPP Lab Record","path":"/2025/01/15/CSAPP-Lab-Record/","content":"以前写的CSAPP Lab记录https://blog.csdn.net/qq_40955029?spm=1000.2115.3001.5343"}]